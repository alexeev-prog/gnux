# Как увеличить скорость python-программы благодаря C-расширениям.
Во время разработки ПО мы сталкиваемся с выбором между удобством языка и его производительностью. Python завоевал популярность благодаря простоте и изящности, но когда дело доходит до низкоуровневых действий или махинаций, требующие производительность и быстроту, на помощь приходит C.

Мы будем изучать именно интеграцию расширений во времени сборки, а не просто загрузка библиотек через ctypes.

В этой статье я хочу рассказать о том, как интегрировать C-расширения с использованием библиотеки Python.h. Я также расскажу как создать свою python-библиотеку с C-расширениями. Также мы исследуем, как устроен Python - например, вспомним, что все является объектами. Я буду использовать poetry как менеджер рабочего окружения.

Понимание этой концепции сделает возможным для нас создавать производительные приложения и библиотеки.

Не буду тянуть, начнем!

---

Итак, допустим, вы хотите реализовать какой-либо функционал в вашем проекте. Но понимаете, что чистый python слишком медленный или слишком высокоуровневый для решения вашей задачи. Поэтому можно создавать C-расширения, в которых будет реализован код, который критичен к скорости выполнения.

 > C-расширения доступны только для cpython - эталонной реализации python.

Также python позволяет создавать C-расширения, выполняющие операции без GIL - Global Interpreter Lock.

![](https://habrastorage.org/r/w1560/getpro/habr/post_images/186/54c/962/18654c9629e7361c85336380dd7c466d.png)

 > GIL накладывает некоторые ограничения на потоки, а именно что нельзя использовать несколько процессоров одновремено. Он представляет собой мьютекс, который блокирует доступ к объекту Python interpreter в многопоточных средах, разрешая выполнять лишь одну инструкцию за раз. Этот механизм, хоть и заботится о целостности данных, может тормозить работу программы.

Но также можно и другие задачи переложить на C-расширения, такие как:

 + Вычисления с высокой интенсивностью: алгоритмы, требующие большое количество тяжелых математических операций. Например, быстрое преобразование Фурье (которое мы рассмотрим в этой статье) или сложные операции с матрицами.
 + Низкоуровневое программирование: прямой доступ к памяти, системные вызовы, низкоуровневая работа с сокетами и устройствами ввода/вывода.
 + Реализация функционала, который часто используется и является узким местом.
 + Непосредственная работа с C-библиотеками.
 + Алгоритмы компрессии и декомпрессии данных.

 > Важно понимать, что иногда не стоит все писать на C, иногда можно обойтись обычными оптимизациями и профилированием.

# Настройка окружения
Итак, как обычно начинается создание проектов на python? Банально создание виртуального окружения

```bash
python3 -m venv venv
source venv/bin/activate
```

Но в этом проекте я решил отойти от такого способа, и использовать вместо этого систему правлению проектами Poetry. Poetry — это инструмент для управления зависимостями и сборкой пакетов в Python. А также при помощи Poetry очень легко опубликовать свою библиотеку на PyPi!

В Poetry представлен полный набор инструментов, которые могут понадобиться для детерминированного управления проектами на Python. В том числе, сборка пакетов, поддержка разных версий языка, тестирование и развертывание проектов.

Все началось с того, что создателю Poetry Себастьену Юстасу потребовался единый инструмент для управления проектами от начала до конца, надежный и интуитивно понятный, который бы мог использоваться и в рамках сообщества. Одного лишь менеджера зависимостей было недостаточно, чтобы управлять запуском тестов, процессом развертывания и всем созависимым окружением. Этот функционал находится за гранью возможностей обычных пакетных менеджеров, таких как Pip или Conda. Так появился Python Poetry.

Установить poetry можно через pipx: `pipx install poetry` и через pip: `pip install poetry --break-system-requirements`. Это установит poetry глобально во всю систему.

Давайте инициализируем проект в домашней директории:

```bash
poetry init
```

Но для того, чтобы мы могли писать расширения на C, нам нужно будет получить доступ к C API Python (к заголовочному файлу python.h). Для этого надо установить пакет `python-dev` или `python3-dev`.

Но это еще не все. Так как мы используем расширения на компилируемом языке C, надо будет создать скрипт для сборки:

```python
"""Build script."""

from setuptools import Extension
from setuptools.command.build_ext import build_ext

extensions = [
	Extension("gnuxlinux.ext", sources=["ext/src/gnuxmodule.c"]),
	Extension("gnuxlinux.mkdir", sources=["ext/src/gnuxmkdir.c"]),
	Extension("gnuxlinux.cat", sources=["ext/src/gnuxcat.c"]),
]


class BuildFailed(Exception):
	pass


class ExtBuilder(build_ext):
	def run(self):
		try:
			build_ext.run(self)
		except (Exception) as ex:
			print(ex)

	def build_extension(self, ext):
		try:
			build_ext.build_extension(self, ext)
		except Exception as ex:
			print(ex)


def build(setup_kwargs):
	setup_kwargs.update(
		{"ext_modules": extensions, "cmdclass": {"build_ext": ExtBuilder}}
	)
```

Мой проект называется gnuxlinux, я буду реализовывать некоторые утилиты из GNU Core Utils и не только. Давайте разберем код:

```python
extensions = [
	Extension("gnuxlinux.ext", sources=["ext/src/gnuxmodule.c"]),
	Extension("gnuxlinux.mkdir", sources=["ext/src/gnuxmkdir.c"]),
	Extension("gnuxlinux.cat", sources=["ext/src/gnuxcat.c"]),
]
```

Это список расширений, названий модулей и путей до файлов исходного кода.

```
ext
└── src
    ├── gnuxcat.c
    ├── gnuxmkdir.c
    └── gnuxmodule.c
```
